<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asynchronize: jack::sticky_event Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asynchronize
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>jack</b></li><li class="navelem"><a class="el" href="classjack_1_1sticky__event.html">sticky_event</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classjack_1_1sticky__event-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">jack::sticky_event Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A thread synchronization object that garauntees one thread is woken per <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> call. This means that if no threads are waiting when <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> is called, the next wait will return immediately.  
 <a href="classjack_1_1sticky__event.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="asynchronize_8hpp_source.html">asynchronize.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab191704c8a9ccf251abbb0c7c5c68b46"><td class="memItemLeft" align="right" valign="top"><a id="ab191704c8a9ccf251abbb0c7c5c68b46" name="ab191704c8a9ccf251abbb0c7c5c68b46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> ()</td></tr>
<tr class="memdesc:ab191704c8a9ccf251abbb0c7c5c68b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the calling thread until another thread has called set. If multiple threads are waiting, it is unspecified which will be woken. <br /></td></tr>
<tr class="separator:ab191704c8a9ccf251abbb0c7c5c68b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f253ca86de522733824ccd7404cde5"><td class="memTemplParams" colspan="2">template&lt;typename rep , typename period &gt; </td></tr>
<tr class="memitem:a92f253ca86de522733824ccd7404cde5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjack_1_1sticky__event.html#a92f253ca86de522733824ccd7404cde5">wait_for</a> (std::chrono::duration&lt; rep, period &gt; duration)</td></tr>
<tr class="memdesc:a92f253ca86de522733824ccd7404cde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the calling thread until another thread has called <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> or until the duration expires. If multiple threads are waiting, it is unspecified which will be woken.  <a href="classjack_1_1sticky__event.html#a92f253ca86de522733824ccd7404cde5">More...</a><br /></td></tr>
<tr class="separator:a92f253ca86de522733824ccd7404cde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7ca0f923440a6828892f17850a33d3"><td class="memTemplParams" colspan="2">template&lt;typename clock , typename duration &gt; </td></tr>
<tr class="memitem:aec7ca0f923440a6828892f17850a33d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjack_1_1sticky__event.html#aec7ca0f923440a6828892f17850a33d3">wait_until</a> (std::chrono::time_point&lt; clock, duration &gt; timeout)</td></tr>
<tr class="memdesc:aec7ca0f923440a6828892f17850a33d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the calling thread until another thread has called <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> or until the timeout is reached. If multiple threads are waiting, it is unspecified which will be woken.  <a href="classjack_1_1sticky__event.html#aec7ca0f923440a6828892f17850a33d3">More...</a><br /></td></tr>
<tr class="separator:aec7ca0f923440a6828892f17850a33d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c75de1ca26c0513fafb2f138027f3"><td class="memItemLeft" align="right" valign="top"><a id="a3c0c75de1ca26c0513fafb2f138027f3" name="a3c0c75de1ca26c0513fafb2f138027f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> ()</td></tr>
<tr class="memdesc:a3c0c75de1ca26c0513fafb2f138027f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal flag and wake at most one waiting thread. If there are no waiters, the next call to wait will return immediately. If there are multiple waiters, it is unspecified which will be woken. <br /></td></tr>
<tr class="separator:a3c0c75de1ca26c0513fafb2f138027f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c9524ed0f991626c52e35ef697da6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjack_1_1sticky__event.html#a49c9524ed0f991626c52e35ef697da6e">is_set</a> ()</td></tr>
<tr class="memdesc:a49c9524ed0f991626c52e35ef697da6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the internal flag is set.  <a href="classjack_1_1sticky__event.html#a49c9524ed0f991626c52e35ef697da6e">More...</a><br /></td></tr>
<tr class="separator:a49c9524ed0f991626c52e35ef697da6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5cea0f2d1a953c42dee9b676d07063"><td class="memItemLeft" align="right" valign="top"><a id="a0e5cea0f2d1a953c42dee9b676d07063" name="a0e5cea0f2d1a953c42dee9b676d07063"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="memdesc:a0e5cea0f2d1a953c42dee9b676d07063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal flag so future wait calls will block. <br /></td></tr>
<tr class="separator:a0e5cea0f2d1a953c42dee9b676d07063"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A thread synchronization object that garauntees one thread is woken per <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> call. This means that if no threads are waiting when <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> is called, the next wait will return immediately. </p>
<dl class="section note"><dt>Note</dt><dd>Calling <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> multiple times between waiters will have no additional effect. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a49c9524ed0f991626c52e35ef697da6e" name="a49c9524ed0f991626c52e35ef697da6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c9524ed0f991626c52e35ef697da6e">&#9670;&#160;</a></span>is_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jack::sticky_event::is_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the internal flag is set. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the flag is set, else false </dd></dl>

</div>
</div>
<a id="a92f253ca86de522733824ccd7404cde5" name="a92f253ca86de522733824ccd7404cde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f253ca86de522733824ccd7404cde5">&#9670;&#160;</a></span>wait_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename rep , typename period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jack::sticky_event::wait_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; rep, period &gt;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block the calling thread until another thread has called <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> or until the duration expires. If multiple threads are waiting, it is unspecified which will be woken. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>maximum duration thread should wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> was called; false if duration expired </dd></dl>

</div>
</div>
<a id="aec7ca0f923440a6828892f17850a33d3" name="aec7ca0f923440a6828892f17850a33d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7ca0f923440a6828892f17850a33d3">&#9670;&#160;</a></span>wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename clock , typename duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jack::sticky_event::wait_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; clock, duration &gt;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block the calling thread until another thread has called <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> or until the timeout is reached. If multiple threads are waiting, it is unspecified which will be woken. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>maximum time point at which thread should stop waiting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classjack_1_1sticky__event.html#a3c0c75de1ca26c0513fafb2f138027f3" title="Set the internal flag and wake at most one waiting thread. If there are no waiters,...">set()</a> was called; false if timeout was reached </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jack/projects/asynchronize/include/jack/<a class="el" href="asynchronize_8hpp_source.html">asynchronize.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
