<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asynchronize: jack::broadcast_event Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">asynchronize
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>jack</b></li><li class="navelem"><a class="el" href="classjack_1_1broadcast__event.html">broadcast_event</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classjack_1_1broadcast__event-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">jack::broadcast_event Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functionally similar to <a class="el" href="classjack_1_1unicast__event.html" title="A simple wrapper around a boolean, mutex, and condition variable for concise thread synchronization....">jack::unicast_event</a> except for ... TODO.  
 <a href="classjack_1_1broadcast__event.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="asynchronize_8hpp_source.html">asynchronize.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a92bafe9ec8345ec97488ce9b87b99eff"><td class="memItemLeft" align="right" valign="top"><a id="a92bafe9ec8345ec97488ce9b87b99eff" name="a92bafe9ec8345ec97488ce9b87b99eff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> ()</td></tr>
<tr class="memdesc:a92bafe9ec8345ec97488ce9b87b99eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the calling thread until another thread calls <a class="el" href="classjack_1_1broadcast__event.html#ab59282e2d5d0eb5b11580dc817ed8078" title="Wake N waiting threads, where N is the number of threads currently in the waiting pool....">set()</a>. <br /></td></tr>
<tr class="separator:a92bafe9ec8345ec97488ce9b87b99eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa45d8ea7fb88ef1ceff79cb61a5ede6"><td class="memTemplParams" colspan="2">template&lt;typename rep , typename period &gt; </td></tr>
<tr class="memitem:aaa45d8ea7fb88ef1ceff79cb61a5ede6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjack_1_1broadcast__event.html#aaa45d8ea7fb88ef1ceff79cb61a5ede6">wait_for</a> (std::chrono::duration&lt; rep, period &gt; duration)</td></tr>
<tr class="memdesc:aaa45d8ea7fb88ef1ceff79cb61a5ede6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the calling thread until another thread calls <a class="el" href="classjack_1_1broadcast__event.html#ab59282e2d5d0eb5b11580dc817ed8078" title="Wake N waiting threads, where N is the number of threads currently in the waiting pool....">set()</a> or until the duration expires.  <a href="classjack_1_1broadcast__event.html#aaa45d8ea7fb88ef1ceff79cb61a5ede6">More...</a><br /></td></tr>
<tr class="separator:aaa45d8ea7fb88ef1ceff79cb61a5ede6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09d398d61d7de2acbdc8990152179f6"><td class="memTemplParams" colspan="2">template&lt;typename clock , typename duration &gt; </td></tr>
<tr class="memitem:ab09d398d61d7de2acbdc8990152179f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjack_1_1broadcast__event.html#ab09d398d61d7de2acbdc8990152179f6">wait_until</a> (std::chrono::time_point&lt; clock, duration &gt; timeout)</td></tr>
<tr class="memdesc:ab09d398d61d7de2acbdc8990152179f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the calling thread until another thread calls <a class="el" href="classjack_1_1broadcast__event.html#ab59282e2d5d0eb5b11580dc817ed8078" title="Wake N waiting threads, where N is the number of threads currently in the waiting pool....">set()</a> or until the timeout is reached.  <a href="classjack_1_1broadcast__event.html#ab09d398d61d7de2acbdc8990152179f6">More...</a><br /></td></tr>
<tr class="separator:ab09d398d61d7de2acbdc8990152179f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59282e2d5d0eb5b11580dc817ed8078"><td class="memItemLeft" align="right" valign="top"><a id="ab59282e2d5d0eb5b11580dc817ed8078" name="ab59282e2d5d0eb5b11580dc817ed8078"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> ()</td></tr>
<tr class="memdesc:ab59282e2d5d0eb5b11580dc817ed8078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake N waiting threads, where N is the number of threads currently in the waiting pool. It is possible that new waiters will enter the pool between this call and the Nth thread waking which can lead to a different group waking than that which consituted the pool at the time of this call. If this behavior is undesireable, use <a class="el" href="classjack_1_1multicast__event.html" title="Functionally similar to jack::unicast_event except for two differences. Firstly, set() calls wake all...">jack::multicast_event</a>. <br /></td></tr>
<tr class="separator:ab59282e2d5d0eb5b11580dc817ed8078"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Functionally similar to <a class="el" href="classjack_1_1unicast__event.html" title="A simple wrapper around a boolean, mutex, and condition variable for concise thread synchronization....">jack::unicast_event</a> except for ... TODO. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aaa45d8ea7fb88ef1ceff79cb61a5ede6" name="aaa45d8ea7fb88ef1ceff79cb61a5ede6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa45d8ea7fb88ef1ceff79cb61a5ede6">&#9670;&#160;</a></span>wait_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename rep , typename period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jack::broadcast_event::wait_for </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; rep, period &gt;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block the calling thread until another thread calls <a class="el" href="classjack_1_1broadcast__event.html#ab59282e2d5d0eb5b11580dc817ed8078" title="Wake N waiting threads, where N is the number of threads currently in the waiting pool....">set()</a> or until the duration expires. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>maximum duration thread should wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classjack_1_1broadcast__event.html#ab59282e2d5d0eb5b11580dc817ed8078" title="Wake N waiting threads, where N is the number of threads currently in the waiting pool....">set()</a> was called; false if duration expired </dd></dl>

</div>
</div>
<a id="ab09d398d61d7de2acbdc8990152179f6" name="ab09d398d61d7de2acbdc8990152179f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09d398d61d7de2acbdc8990152179f6">&#9670;&#160;</a></span>wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename clock , typename duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jack::broadcast_event::wait_until </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; clock, duration &gt;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block the calling thread until another thread calls <a class="el" href="classjack_1_1broadcast__event.html#ab59282e2d5d0eb5b11580dc817ed8078" title="Wake N waiting threads, where N is the number of threads currently in the waiting pool....">set()</a> or until the timeout is reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>maximum time point at which thread should stop waiting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classjack_1_1broadcast__event.html#ab59282e2d5d0eb5b11580dc817ed8078" title="Wake N waiting threads, where N is the number of threads currently in the waiting pool....">set()</a> was called; false if timeout was reached </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jack/projects/asynchronize/include/jack/<a class="el" href="asynchronize_8hpp_source.html">asynchronize.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
